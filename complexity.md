---
title: 复杂度分析
date: 2019-04-26 23:05:56
tags: [数据结构, 算法]
categories:
- 数据结构与算法
---
不用具体的测试数据来测试，就可以粗略地估计算法的执行效率。<!-- more -->

# 大 O 复杂度表示法

粗略估计可以假设每行代码执行的时间都一样，为 unit_time。比如：

```JavaScript
function cal(n) {
    let sum = 0
    let i = 1
    for (; i <= n; i++) {
        sum += i
    }
    return sum
}
```

第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以一共需要 2n\*unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)\*unit_time。可以看出来，所有代码的执行时间 T(n) 与每行代码的执行次数总和 f(n) 成正比。

用一个公式来表示，即 `T(n) = O(f(n))`，将上述例子表示成公式形式即为 T(n) = O(2n+2)。

# 时间复杂度分析

大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势。

关键在于：公式中的**低阶**、**常量**、**系数**三部分并不左右增长趋势，所以都可以忽略，我们只需要记录一个**最大量级**就可以了。

## 方法

### 只关注循环执行次数最多的一段代码

比如上述例子，第 2、3 行代码都是常量级的执行时间，与 n 的大小无关，所以对于复杂度并没有影响，可以忽略。循环执行次数最多的是第 4、5 行代码，所以这块代码要重点分析。忽略系数，即为 T(n) = O(n)。

### 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

比如：

```JavaScript
function cal(n) {
    let sum = 0
    let p = 1
    let q = 1
    for (; p <= n; p++) {
        q = 1 //使下列循环从1开始
        for (; q <= n; q++) {
            sum += p * q
        }
    }

    return sum
}
```

第一个 for 循环和第二个 for 循环的时间复杂度都为 O(n)，所以整段代码的时间复杂度为 O($n^2$)。

### 加法法则：总复杂度等于量级最大的那段代码的复杂度

比如：

```JavaScript
function cal(n) {
    let sum1 = 0
    let i = 1
    for (; i <= n; i++) {
        sum1 += i
    }

    let sum2 = 0
    let p = 1
    let q = 1
    for (; p <= n; p++) {
        q = 1 //使下列循环从1开始
        for (; q <= n; q++) {
            sum2 += p * q
        }
    }

    return sum1 + sum2
}
```

第一个代码块时间复杂度 O(n)，第二个代码块时间复杂度 O(n^2)。取其中最大的量级，所以，整段代码的时间复杂度就为 O(n^2)。

## 常见时间复杂度

可以粗略地分为两类，多项式量级和非多项式量级。对此，拓展可以看看[知乎](https://www.zhihu.com/question/27039635)和[Matrix67](http://www.matrix67.com/blog/archives/105)。

### 多项式量级

#### O(1)

常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。

#### O(logn)、O(nlogn)

比如：

```JavaScript
let i = 1
while (i <= n) {
    i = i * 2
}
```

关注第三行代码。

- 当 n = 1 时，执行1次；
- 当 n = 2 时，执行2次；
- 当 n = 4 时，执行3次；
- ...
- 当 n = n 时，执行 $log_2n+1$ 次。

所以 T(n) = O(logn)。如果该代码块嵌套了，就可以是 O(nlogn)。

#### O(m+n)、O(m\*n)

代码的复杂度由两个数据的规模来决定，比如：

```JavaScript
function cal(m, n) {
    let sum1 = 0
    let i = 1
    for (; i <= m; i++) {
        sum1 += i
    }

    let sum2 = 0
    let j = 1
    for (; j <= n; j++) {
        sum2 += j
    }

    return sum1 + sum2
}
```

从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。

针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)\*T2(n) = O(f(m) \* f(n))。

### 非多项式量级

只有两个：O(2^n) 和 O(n!)。

## 最好、最坏、平均、均摊时间复杂度

### 最好、最坏情况时间复杂度

比如先看下面一段代码：

```JavaScript
// n 表示数组 array 的长度，x 表示要查找的变量
function find(array, n, x) {
    let i = 0;
    let pos = -1;
    for (; i < n; i++) {
        if (array[i] == x) {
            pos = i;
            break;
        }
    }
    return pos;
}
```
要查找的变量 x 可能出现在数组的任意位置。如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)，此时就是**最好时间复杂度**。但如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)，此时就是**最坏时间复杂度**。

### 平均时间复杂度

同上段代码，假设要查找的变量 x 在数组中与不在数组中的概率都为 1/2，出现在 0～n-1 这 n 个位置的概率为 1/n。所以，根据概率乘法法则，x 出现在 0～n-1 中任意位置的概率就是 1/(2n)。每种情况的时间复杂度分别为1，2，3...。所以平均时间复杂度计算公式为 1\*1/2n + 2\*1/2n +...+ n\*1/2n + n*1/2 = (3n+1)/4，所以平均时间复杂度为 O(n)。

### 均摊时间复杂度

先看下面代码：

```JavaScript
// array 表示一个长度为 n 的数组
// 代码中的 array.length 就等于 n
let count = 0;

function insert(val) {
    if (count == array.length) {
        let sum = 0;
        for (let i = 0; i < array.length; i++) {
            sum = sum + array[i];
        }
        array[0] = sum;
        count = 1;
    }

    array[count] = val;
    count++;
}
```

这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入,此时的时间复杂度为 O(n)。但如果数组一开始就有空闲空间，则直接将数据插入数组此时的时间复杂度就为 O(1)。

数组的长度为 n，在每个位置插入数据有 n 种情况。如果没有空闲位置，则是第 n+1 种情况。每种情况概率相同，都为 1/(n+1)，所以平均时间复杂度的计算公式为 1\*1/(n+1) + 1\*1/(n+1) +...+ 1\*1/(n+1) + n\*1/(n+1) = O(1)，即平均时间复杂度为 O(1)。

如果函数在大部分情况下复杂度 O(1) 且有规律地循环往复，均摊时间复杂度就是一种特殊的平均时间复杂度。每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。

# 空间复杂度分析

方法与时间复杂度类似。